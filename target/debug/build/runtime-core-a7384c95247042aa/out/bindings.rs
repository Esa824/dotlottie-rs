/* automatically generated by rust-bindgen 0.65.1 */

pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Tvg_Canvas {
    _unused: [u8; 0],
}
#[doc = " \\brief A structure responsible for managing and drawing graphical elements.\n\n It sets up the target buffer, which can be drawn on the screen. It stores the Tvg_Paint objects (Shape, Scene, Picture)."]
pub type Tvg_Canvas = _Tvg_Canvas;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Tvg_Paint {
    _unused: [u8; 0],
}
#[doc = " \\brief A structure representing a graphical element.\n\n \\warning The TvgPaint objects can not be shared between Canvases."]
pub type Tvg_Paint = _Tvg_Paint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Tvg_Gradient {
    _unused: [u8; 0],
}
#[doc = " \\brief A structure representing a gradient fill of a Tvg_Paint object."]
pub type Tvg_Gradient = _Tvg_Gradient;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Tvg_Saver {
    _unused: [u8; 0],
}
#[doc = " \\brief A structure representing an object that enables to save a Tvg_Paint object into a file."]
pub type Tvg_Saver = _Tvg_Saver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Tvg_Animation {
    _unused: [u8; 0],
}
#[doc = " \\brief A structure representing an animation controller object. (BETA_API)"]
pub type Tvg_Animation = _Tvg_Animation;
#[doc = "< CPU rasterizer."]
pub const Tvg_Engine_TVG_ENGINE_SW: Tvg_Engine = 2;
#[doc = "< OpenGL rasterizer."]
pub const Tvg_Engine_TVG_ENGINE_GL: Tvg_Engine = 4;
#[doc = " \\brief Enumeration specifying the engine type used for the graphics backend. For multiple backends bitwise operation is allowed.\n\n \\ingroup ThorVGCapi_Initializer"]
pub type Tvg_Engine = ::std::os::raw::c_uint;
#[doc = "< The value returned in case of a correct request execution."]
pub const Tvg_Result_TVG_RESULT_SUCCESS: Tvg_Result = 0;
#[doc = "< The value returned in the event of a problem with the arguments given to the API - e.g. empty paths or null pointers."]
pub const Tvg_Result_TVG_RESULT_INVALID_ARGUMENT: Tvg_Result = 1;
#[doc = "< The value returned in case the request cannot be processed - e.g. asking for properties of an object, which does not exist."]
pub const Tvg_Result_TVG_RESULT_INSUFFICIENT_CONDITION: Tvg_Result = 2;
#[doc = "< The value returned in case of unsuccessful memory allocation."]
pub const Tvg_Result_TVG_RESULT_FAILED_ALLOCATION: Tvg_Result = 3;
#[doc = "< The value returned in the event of bad memory handling - e.g. failing in pointer releasing or casting"]
pub const Tvg_Result_TVG_RESULT_MEMORY_CORRUPTION: Tvg_Result = 4;
#[doc = "< The value returned in case of choosing unsupported options."]
pub const Tvg_Result_TVG_RESULT_NOT_SUPPORTED: Tvg_Result = 5;
#[doc = "< The value returned in all other cases."]
pub const Tvg_Result_TVG_RESULT_UNKNOWN: Tvg_Result = 6;
#[doc = " \\brief Enumeration specifying the result from the APIs."]
pub type Tvg_Result = ::std::os::raw::c_uint;
#[doc = "< No composition is applied."]
pub const Tvg_Composite_Method_TVG_COMPOSITE_METHOD_NONE: Tvg_Composite_Method = 0;
#[doc = "< The intersection of the source and the target is determined and only the resulting pixels from the source are rendered."]
pub const Tvg_Composite_Method_TVG_COMPOSITE_METHOD_CLIP_PATH: Tvg_Composite_Method = 1;
#[doc = "< The pixels of the source and the target are alpha blended. As a result, only the part of the source, which intersects with the target is visible."]
pub const Tvg_Composite_Method_TVG_COMPOSITE_METHOD_ALPHA_MASK: Tvg_Composite_Method = 2;
#[doc = "< The pixels of the source and the complement to the target's pixels are alpha blended. As a result, only the part of the source which is not covered by the target is visible."]
pub const Tvg_Composite_Method_TVG_COMPOSITE_METHOD_INVERSE_ALPHA_MASK: Tvg_Composite_Method = 3;
#[doc = "< The source pixels are converted to grayscale (luma value) and alpha blended with the target. As a result, only the part of the source which intersects with the target is visible. \\since 0.9"]
pub const Tvg_Composite_Method_TVG_COMPOSITE_METHOD_LUMA_MASK: Tvg_Composite_Method = 4;
#[doc = "< The source pixels are converted to grayscale (luma value) and complement to the target's pixels are alpha blended. As a result, only the part of the source which is not covered by the target is visible. \\BETA_API"]
pub const Tvg_Composite_Method_TVG_COMPOSITE_METHOD_INVERSE_LUMA_MASK: Tvg_Composite_Method = 5;
#[doc = " \\brief Enumeration indicating the method used in the composition of two objects - the target and the source.\n\n \\ingroup ThorVGCapi_Paint"]
pub type Tvg_Composite_Method = ::std::os::raw::c_uint;
#[doc = "< Undefined type."]
pub const Tvg_Identifier_TVG_IDENTIFIER_UNDEF: Tvg_Identifier = 0;
#[doc = "< A shape type paint."]
pub const Tvg_Identifier_TVG_IDENTIFIER_SHAPE: Tvg_Identifier = 1;
#[doc = "< A scene type paint."]
pub const Tvg_Identifier_TVG_IDENTIFIER_SCENE: Tvg_Identifier = 2;
#[doc = "< A picture type paint."]
pub const Tvg_Identifier_TVG_IDENTIFIER_PICTURE: Tvg_Identifier = 3;
#[doc = "< A linear gradient type."]
pub const Tvg_Identifier_TVG_IDENTIFIER_LINEAR_GRAD: Tvg_Identifier = 4;
#[doc = "< A radial gradient type."]
pub const Tvg_Identifier_TVG_IDENTIFIER_RADIAL_GRAD: Tvg_Identifier = 5;
#[doc = " \\brief Enumeration indicating the ThorVG class type.\n\n \\ingroup ThorVGCapi_Paint\n\n \\since 0.9"]
pub type Tvg_Identifier = ::std::os::raw::c_uint;
#[doc = "< Ends the current sub-path and connects it with its initial point - corresponds to Z command in the svg path commands."]
pub const Tvg_Path_Command_TVG_PATH_COMMAND_CLOSE: Tvg_Path_Command = 0;
#[doc = "< Sets a new initial point of the sub-path and a new current point - corresponds to M command in the svg path commands."]
pub const Tvg_Path_Command_TVG_PATH_COMMAND_MOVE_TO: Tvg_Path_Command = 1;
#[doc = "< Draws a line from the current point to the given point and sets a new value of the current point - corresponds to L command in the svg path commands."]
pub const Tvg_Path_Command_TVG_PATH_COMMAND_LINE_TO: Tvg_Path_Command = 2;
#[doc = "< Draws a cubic Bezier curve from the current point to the given point using two given control points and sets a new value of the current point - corresponds to C command in the svg path commands."]
pub const Tvg_Path_Command_TVG_PATH_COMMAND_CUBIC_TO: Tvg_Path_Command = 3;
#[doc = " \\brief Enumeration specifying the values of the path commands accepted by TVG.\n\n Not to be confused with the path commands from the svg path element (like M, L, Q, H and many others).\n TVG interprets all of them and translates to the ones from the PathCommand values."]
pub type Tvg_Path_Command = ::std::os::raw::c_uint;
#[doc = "< The stroke is extended in both endpoints of a sub-path by a rectangle, with the width equal to the stroke width and the length equal to the half of the stroke width. For zero length sub-paths the square is rendered with the size of the stroke width."]
pub const Tvg_Stroke_Cap_TVG_STROKE_CAP_SQUARE: Tvg_Stroke_Cap = 0;
#[doc = "< The stroke is extended in both endpoints of a sub-path by a half circle, with a radius equal to the half of a stroke width. For zero length sub-paths a full circle is rendered."]
pub const Tvg_Stroke_Cap_TVG_STROKE_CAP_ROUND: Tvg_Stroke_Cap = 1;
#[doc = "< The stroke ends exactly at each of the two endpoints of a sub-path. For zero length sub-paths no stroke is rendered."]
pub const Tvg_Stroke_Cap_TVG_STROKE_CAP_BUTT: Tvg_Stroke_Cap = 2;
#[doc = " \\brief Enumeration determining the ending type of a stroke in the open sub-paths."]
pub type Tvg_Stroke_Cap = ::std::os::raw::c_uint;
#[doc = "< The outer corner of the joined path segments is bevelled at the join point. The triangular region of the corner is enclosed by a straight line between the outer corners of each stroke."]
pub const Tvg_Stroke_Join_TVG_STROKE_JOIN_BEVEL: Tvg_Stroke_Join = 0;
#[doc = "< The outer corner of the joined path segments is rounded. The circular region is centered at the join point."]
pub const Tvg_Stroke_Join_TVG_STROKE_JOIN_ROUND: Tvg_Stroke_Join = 1;
#[doc = "< The outer corner of the joined path segments is spiked. The spike is created by extension beyond the join point of the outer edges of the stroke until they intersect. In case the extension goes beyond the limit, the join style is converted to the Bevel style."]
pub const Tvg_Stroke_Join_TVG_STROKE_JOIN_MITER: Tvg_Stroke_Join = 2;
#[doc = " \\brief Enumeration specifying how to fill the area outside the gradient bounds."]
pub type Tvg_Stroke_Join = ::std::os::raw::c_uint;
#[doc = "< The remaining area is filled with the closest stop color."]
pub const Tvg_Stroke_Fill_TVG_STROKE_FILL_PAD: Tvg_Stroke_Fill = 0;
#[doc = "< The gradient pattern is reflected outside the gradient area until the expected region is filled."]
pub const Tvg_Stroke_Fill_TVG_STROKE_FILL_REFLECT: Tvg_Stroke_Fill = 1;
#[doc = "< The gradient pattern is repeated continuously beyond the gradient area until the expected region is filled."]
pub const Tvg_Stroke_Fill_TVG_STROKE_FILL_REPEAT: Tvg_Stroke_Fill = 2;
#[doc = " \\brief Enumeration specifying how to fill the area outside the gradient bounds."]
pub type Tvg_Stroke_Fill = ::std::os::raw::c_uint;
#[doc = "< A line from the point to a location outside the shape is drawn. The intersections of the line with the path segment of the shape are counted. Starting from zero, if the path segment of the shape crosses the line clockwise, one is added, otherwise one is subtracted. If the resulting sum is non zero, the point is inside the shape."]
pub const Tvg_Fill_Rule_TVG_FILL_RULE_WINDING: Tvg_Fill_Rule = 0;
#[doc = "< A line from the point to a location outside the shape is drawn and its intersections with the path segments of the shape are counted. If the number of intersections is an odd number, the point is inside the shape."]
pub const Tvg_Fill_Rule_TVG_FILL_RULE_EVEN_ODD: Tvg_Fill_Rule = 1;
#[doc = " \\brief Enumeration specifying the algorithm used to establish which parts of the shape are treated as the inside of the shape."]
pub type Tvg_Fill_Rule = ::std::os::raw::c_uint;
#[doc = " \\brief A data structure storing the information about the color and its relative position inside the gradient bounds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tvg_Color_Stop {
    #[doc = "< The relative position of the color."]
    pub offset: f32,
    #[doc = "< The red color channel value in the range [0 ~ 255]."]
    pub r: u8,
    #[doc = "< The green color channel value in the range [0 ~ 255]."]
    pub g: u8,
    #[doc = "< The blue color channel value in the range [0 ~ 255]."]
    pub b: u8,
    #[doc = "< The alpha channel value in the range [0 ~ 255], where 0 is completely transparent and 255 is opaque."]
    pub a: u8,
}
#[test]
fn bindgen_test_layout_Tvg_Color_Stop() {
    const UNINIT: ::std::mem::MaybeUninit<Tvg_Color_Stop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Tvg_Color_Stop>(),
        8usize,
        concat!("Size of: ", stringify!(Tvg_Color_Stop))
    );
    assert_eq!(
        ::std::mem::align_of::<Tvg_Color_Stop>(),
        4usize,
        concat!("Alignment of ", stringify!(Tvg_Color_Stop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Color_Stop),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Color_Stop),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Color_Stop),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Color_Stop),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Color_Stop),
            "::",
            stringify!(a)
        )
    );
}
#[doc = " \\brief A data structure representing a point in two-dimensional space."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tvg_Point {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_Tvg_Point() {
    const UNINIT: ::std::mem::MaybeUninit<Tvg_Point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Tvg_Point>(),
        8usize,
        concat!("Size of: ", stringify!(Tvg_Point))
    );
    assert_eq!(
        ::std::mem::align_of::<Tvg_Point>(),
        4usize,
        concat!("Alignment of ", stringify!(Tvg_Point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Point),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief A data structure representing a three-dimensional matrix.\n\n The elements e11, e12, e21 and e22 represent the rotation matrix, including the scaling factor.\n The elements e13 and e23 determine the translation of the object along the x and y-axis, respectively.\n The elements e31 and e32 are set to 0, e33 is set to 1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tvg_Matrix {
    pub e11: f32,
    pub e12: f32,
    pub e13: f32,
    pub e21: f32,
    pub e22: f32,
    pub e23: f32,
    pub e31: f32,
    pub e32: f32,
    pub e33: f32,
}
#[test]
fn bindgen_test_layout_Tvg_Matrix() {
    const UNINIT: ::std::mem::MaybeUninit<Tvg_Matrix> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Tvg_Matrix>(),
        36usize,
        concat!("Size of: ", stringify!(Tvg_Matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<Tvg_Matrix>(),
        4usize,
        concat!("Alignment of ", stringify!(Tvg_Matrix))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e11) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Matrix),
            "::",
            stringify!(e11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e12) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Matrix),
            "::",
            stringify!(e12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e13) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Matrix),
            "::",
            stringify!(e13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e21) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Matrix),
            "::",
            stringify!(e21)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e22) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Matrix),
            "::",
            stringify!(e22)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e23) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Matrix),
            "::",
            stringify!(e23)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e31) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Matrix),
            "::",
            stringify!(e31)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Matrix),
            "::",
            stringify!(e32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e33) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Tvg_Matrix),
            "::",
            stringify!(e33)
        )
    );
}
extern "C" {
    #[doc = "/\n/*!\n \\brief Initializes TVG engines.\n\n TVG requires the running-engine environment.\n TVG runs its own task-scheduler for parallelizing rendering tasks efficiently.\n You can indicate the number of threads, the count of which is designated @p threads.\n In the initialization step, TVG will generate/spawn the threads as set by @p threads count.\n\n \\code\n tvg_engine_init(TVG_ENGINE_SW, 0);  //Initialize software renderer and use the main thread only\n \\endcode\n\n \\param[in] engine_method The engine types to initialize. This is relative to the Canvas types, in which it will be used. For multiple backends bitwise operation is allowed.\n   - TVG_ENGINE_SW: CPU rasterizer\n   - TVG_ENGINE_GL: OpenGL rasterizer (not supported yet)\n \\param[in] threads The number of additional threads used to perform rendering. Zero indicates only the main thread is to be used.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error possibly with memory allocation.\n \\retval TVG_RESULT_INVALID_ARGUMENT Unknown engine type.\n \\retval TVG_RESULT_NOT_SUPPORTED Unsupported engine type.\n \\retval TVG_RESULT_UNKNOWN Other error.\n\n \\note The Initializer keeps track of the number of times it was called. Threads count is fixed at the first init() call.\n \\see tvg_engine_term()\n \\see Tvg_Engine"]
    pub fn tvg_engine_init(
        engine_method: Tvg_Engine,
        threads: ::std::os::raw::c_uint,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Terminates TVG engines.\n\n It should be called in case of termination of the TVG client with the same engine types as were passed when tvg_engine_init() was called.\n\n \\code\n tvg_engine_init(TVG_ENGINE_SW, 0);\n //define canvas and shapes, update shapes, general rendering calls\n tvg_engine_term(TVG_ENGINE_SW);\n \\endcode\n\n \\param engine_method The engine types to terminate. This is relative to the Canvas types, in which it will be used. For multiple backends bitwise operation is allowed\n   - TVG_ENGINE_SW: CPU rasterizer\n   - TVG_ENGINE_GL: OpenGL rasterizer (not supported yet)\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION Nothing to be terminated.\n \\retval TVG_RESULT_INVALID_ARGUMENT Unknown engine type.\n \\retval TVG_RESULT_NOT_SUPPORTED Unsupported engine type.\n \\retval TVG_RESULT_UNKNOWN An internal error.\n\n \\see tvg_engine_init()\n \\see Tvg_Engine"]
    pub fn tvg_engine_term(engine_method: Tvg_Engine) -> Tvg_Result;
}
#[doc = "< Default behavior that ThorVG is designed to."]
pub const Tvg_Mempool_Policy_TVG_MEMPOOL_POLICY_DEFAULT: Tvg_Mempool_Policy = 0;
#[doc = "< Memory Pool is shared among canvases."]
pub const Tvg_Mempool_Policy_TVG_MEMPOOL_POLICY_SHAREABLE: Tvg_Mempool_Policy = 1;
#[doc = "< Allocate designated memory pool that is used only by the current canvas instance."]
pub const Tvg_Mempool_Policy_TVG_MEMPOOL_POLICY_INDIVIDUAL: Tvg_Mempool_Policy = 2;
#[doc = " \\brief Enumeration specifying the methods of Memory Pool behavior policy."]
pub type Tvg_Mempool_Policy = ::std::os::raw::c_uint;
#[doc = "< The 8-bit color channels are combined into 32-bit color in the order: alpha, blue, green, red."]
pub const Tvg_Colorspace_TVG_COLORSPACE_ABGR8888: Tvg_Colorspace = 0;
#[doc = "< The 8-bit color channels are combined into 32-bit color in the order: alpha, red, green, blue."]
pub const Tvg_Colorspace_TVG_COLORSPACE_ARGB8888: Tvg_Colorspace = 1;
#[doc = " \\brief Enumeration specifying the methods of combining the 8-bit color channels into 32-bit color."]
pub type Tvg_Colorspace = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Creates a Canvas object.\n\n \\code\n Tvg_Canvas *canvas = NULL;\n\n tvg_engine_init(TVG_ENGINE_SW, 4);\n canvas = tvg_swcanvas_create();\n\n //set up the canvas buffer\n uint32_t *buffer = NULL;\n buffer = (uint32_t*) malloc(sizeof(uint32_t) * 100 * 100);\n if (!buffer) return;\n\n tvg_swcanvas_set_target(canvas, buffer, 100, 100, 100, TVG_COLORSPACE_ARGB8888);\n\n //set up paints and add them into the canvas before drawing it\n\n tvg_canvas_destroy(canvas);\n tvg_engine_term(TVG_ENGINE_SW);\n \\endcode\n\n \\return A new Tvg_Canvas object."]
    pub fn tvg_swcanvas_create() -> *mut Tvg_Canvas;
}
extern "C" {
    #[doc = " \\brief Sets the buffer used in the rasterization process and defines the used colorspace.\n\n For optimisation reasons TVG does not allocate memory for the output buffer on its own.\n The buffer of a desirable size should be allocated and owned by the caller.\n\n \\param[in] canvas The Tvg_Canvas object managing the @p buffer.\n \\param[in] buffer A pointer to the allocated memory block of the size @p stride x @p h.\n \\param[in] stride The stride of the raster image - in most cases same value as @p w.\n \\param[in] w The width of the raster image.\n \\param[in] h The height of the raster image.\n \\param[in] cs The colorspace value defining the way the 32-bits colors should be read/written.\n - TVG_COLORSPACE_ABGR8888\n - TVG_COLORSPACE_ARGB8888\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_MEMORY_CORRUPTION Casting in the internal function implementation failed.\n \\retval TVG_RESULT_INVALID_ARGUMENTS An invalid canvas or buffer pointer passed or one of the @p stride, @p w or @p h being zero.\n \\retval TVG_RESULT_NOT_SUPPORTED The software engine is not supported.\n\n \\warning Do not access @p buffer during tvg_canvas_draw() - tvg_canvas_sync(). It should not be accessed while TVG is writing on it.\n\n \\see Tvg_Colorspace"]
    pub fn tvg_swcanvas_set_target(
        canvas: *mut Tvg_Canvas,
        buffer: *mut u32,
        stride: u32,
        w: u32,
        h: u32,
        cs: Tvg_Colorspace,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the software engine memory pool behavior policy.\n\n ThorVG draws a lot of shapes, it allocates/deallocates a few chunk of memory\n while processing rendering. It internally uses one shared memory pool\n which can be reused among the canvases in order to avoid memory overhead.\n\n Thus ThorVG suggests using a memory pool policy to satisfy user demands,\n if it needs to guarantee the thread-safety of the internal data access.\n\n \\param[in] canvas The Tvg_Canvas object of which the Memory Pool behavior is to be specified.\n \\param[in] policy The method specifying the Memory Pool behavior. The default value is @c TVG_MEMPOOL_POLICY_DEFAULT.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENTS An invalid canvas pointer passed.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION The canvas contains some paints already.\n \\retval TVG_RESULT_NOT_SUPPORTED The software engine is not supported.\n\n \\note When @c policy is set as @c TVG_MEMPOOL_POLICY_INDIVIDUAL, the current instance of canvas uses its own individual\n       memory data, which is not shared with others. This is necessary when the canvas is accessed on a worker-thread.\n\n \\warning It's not allowed after pushing any paints."]
    pub fn tvg_swcanvas_set_mempool(
        canvas: *mut Tvg_Canvas,
        policy: Tvg_Mempool_Policy,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = "/\n/*!\n \\brief Clears the canvas internal data, releases all paints stored by the canvas and destroys the canvas object itself.\n\n \\code\n static Tvg_Canvas *canvas = NULL;\n static uint32_t *buffer = NULL;\n\n static void _init() {\n   canvas = tvg_swcanvas_create();\n   buffer = (uint32_t*) malloc(sizeof(uint32_t) * 100 * 100);\n   tvg_swcanvas_set_target(canvas, buffer, 100, 100, 100, TVG_COLORSPACE_ARGB8888);\n }\n\n //a task called from main function in a loop\n static void _job(const int cmd) {\n   //define a valid rectangle shape\n   switch (cmd) {\n     case CMD_EXIT: return 0;\n     case CMD_ADD_RECT:\n       tvg_canvas_push(canvas, rect);\n       break;\n     case CMD_DEL_RECT:\n       tvg_paint_del(rect);\n       //now to safely delete Tvg_Canvas, tvg_canvas_clear() API have to be used\n       break;\n     default:\n       break;\n   }\n }\n\n int main(int argc, char **argv) {\n   int cmd = 0;\n   int stop = 1;\n\n   tvg_engine_init(TVG_ENGINE_SW, 4);\n\n   while (stop) {\n      //wait for a command e.g. from a console\n      stop = _job(cmd);\n   }\n   tvg_canvas_clear(canvas, false);\n   tvg_canvas_destroy(canvas);\n   tvg_engine_term(TVG_ENGINE_SW);\n   return 0;\n }\n\n tvg_canvas_destroy(canvas);\n tvg_engine_term(TVG_ENGINE_SW)\n \\endcode\n\n \\param[in] canvas The Tvg_Canvas object to be destroyed.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer to the Tvg_Canvas object is passed.\n\n \\note If the paints from the canvas should not be released, the tvg_canvas_clear() with a @c free argument value set to @c false should be called.\n Please be aware that in such a case TVG is not responsible for the paints release anymore and it has to be done manually in order to avoid memory leaks.\n\n \\see tvg_paint_del(), tvg_canvas_clear()"]
    pub fn tvg_canvas_destroy(canvas: *mut Tvg_Canvas) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Inserts a drawing element into the canvas using a Tvg_Paint object.\n\n \\param[in] canvas The Tvg_Canvas object managing the @p paint.\n \\param[in] paint The Tvg_Paint object to be drawn.\n\n Only the paints pushed into the canvas will be drawing targets.\n They are retained by the canvas until you call tvg_canvas_clear().\n If you know the number of the pushed objects in advance, please call tvg_canvas_reserve().\n\n \\return Tvg_Result return values:\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT In case a @c nullptr is passed as the argument.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION An internal error.\n\n \\note The rendering order of the paints is the same as the order as they were pushed. Consider sorting the paints before pushing them if you intend to use layering.\n \\see tvg_canvas_clear()"]
    pub fn tvg_canvas_push(canvas: *mut Tvg_Canvas, paint: *mut Tvg_Paint) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Reserves a memory block where the objects pushed into a canvas are stored.\n\n If the number of Tvg_Paints to be stored in a canvas is known in advance, calling this function reduces the multiple\n memory allocations thus improves the performance.\n\n \\code\n Tvg_Canvas *canvas = NULL;\n\n tvg_engine_init(TVG_ENGINE_SW, 4);\n canvas = tvg_swcanvas_create();\n\n uint32_t *buffer = NULL;\n buffer = (uint32_t*) malloc(sizeof(uint32_t) * 100 * 100);\n if (!buffer) return;\n\n tvg_swcanvas_set_target(canvas, buffer, 100, 100, 100, TVG_COLORSPACE_ARGB8888);\n\n tvg_canvas_destroy(canvas);\n tvg_engine_term(TVG_ENGINE_SW)\n \\endcode\n\n \\param[in] canvas The Tvg_Canvas object managing the reserved memory.\n \\param[in] n The number of objects for which the memory is to be reserved.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Canvas pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with memory allocation."]
    pub fn tvg_canvas_reserve(canvas: *mut Tvg_Canvas, n: u32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the total number of the paints pushed into the canvas to be zero.\n Tvg_Paint objects stored in the canvas are released if @p free is set to @c true, otherwise the memory is not deallocated and\n all paints should be released manually in order to avoid memory leaks.\n\n \\param[in] canvas The Tvg_Canvas object to be cleared.\n \\param[in] free If @c true the memory occupied by paints is deallocated, otherwise it is not.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Canvas pointer.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION An internal error.\n\n \\warning Please use the @p free argument only when you know how it works, otherwise it's not recommended.\n\n \\see tvg_canvas_destroy()"]
    pub fn tvg_canvas_clear(canvas: *mut Tvg_Canvas, free: bool) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Updates all paints in a canvas.\n\n Should be called before drawing in order to prepare paints for the rendering.\n\n \\code\n //A frame drawing example. Thread safety and events implementation is skipped to show only TVG code.\n\n static Tvg_Canvas *canvas = NULL;\n static Tvg_Paint *rect = NULL;\n\n int _frame_render(void) {\n   tvg_canvas_update(canvas);\n   tvg_canvas_draw(canvas);\n   tvg_canvas_sync(canvas);\n }\n\n //event handler from your code or third party library\n void _event_handler(event *event_data) {\n   if (!event_data) return NULL;\n     switch(event_data.type) {\n       case EVENT_RECT_ADD:\n         if (!rect) {\n           tvg_shape_append_rect(rect, 10, 10, 50, 50, 0, 0);\n           tvg_shape_set_stroke_width(rect, 1.0f);\n           tvg_shape_set_stroke_color(rect, 255, 0, 0, 255);\n           tvg_canvas_push(canvas, rect);\n         }\n         break;\n       case EVENT_RECT_MOVE:\n         if (rect) tvg_paint_translate(rect, 10.0, 10.0);\n           break;\n         default:\n           break;\n   }\n }\n\n int main(int argc, char **argv) {\n   //example handler from your code or third party lib\n   event_handler_add(handler, _event_handler);\n\n   //create frame rendering process which calls _frame_render() function.\n   app_loop_begin(_frame_render);\n   app_loop_finish();\n   cleanup();\n }\n \\endcode\n\n \\param[in] canvas The Tvg_Canvas object to be updated.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Canvas pointer.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION An internal error.\n\n \\see tvg_canvas_update_paint()"]
    pub fn tvg_canvas_update(canvas: *mut Tvg_Canvas) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Updates the given Tvg_Paint object from the canvas before the rendering.\n\n If a client application using the TVG library does not update the entire canvas with tvg_canvas_update() in the frame\n rendering process, Tvg_Paint objects previously added to the canvas should be updated manually with this function.\n\n \\param[in] canvas The Tvg_Canvas object to which the @p paint belongs.\n \\param[in] paint The Tvg_Paint object to be updated.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT In case a @c nullptr is passed as the argument.\n\n \\see tvg_canvas_update()"]
    pub fn tvg_canvas_update_paint(canvas: *mut Tvg_Canvas, paint: *mut Tvg_Paint) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Requests the canvas to draw the Tvg_Paint objects.\n\n All paints from the given canvas will be rasterized to the buffer.\n\n \\param[in] canvas The Tvg_Canvas object containing elements to be drawn.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Canvas pointer.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION An internal error.\n\n \\note Drawing can be asynchronous based on the assigned thread number. To guarantee the drawing is done, call tvg_canvas_sync() afterwards.\n \\see tvg_canvas_sync()"]
    pub fn tvg_canvas_draw(canvas: *mut Tvg_Canvas) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Guarantees that the drawing process is finished.\n\n Since the canvas rendering can be performed asynchronously, it should be called after the tvg_canvas_draw().\n\n \\param[in] canvas The Tvg_Canvas object containing elements which were drawn.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Canvas pointer.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION An internal error.\n\n \\see tvg_canvas_draw()"]
    pub fn tvg_canvas_sync(canvas: *mut Tvg_Canvas) -> Tvg_Result;
}
extern "C" {
    #[doc = "/\n/*!\n \\brief Releases the given Tvg_Paint object.\n\n \\code\n //example of cleanup function\n Tvg_Paint *rect = NULL; //rectangle shape added in other function\n\n //rectangle delete API\n int rectangle_delete(void) {\n   if (rect) tvg_paint_del(rect);\n   rect = NULL;\n }\n\n int cleanup(void) {\n   tvg_canvas_clear(canvas, false);\n   tvg_canvas_destroy(canvas);\n   canvas = NULL;\n }\n \\endcode\n\n \\param[in] paint The Tvg_Paint object to be released.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n\n \\warning If this function is used, tvg_canvas_clear() with the @c free argument value set to @c false should be used in order to avoid unexpected behaviours.\n\n \\see tvg_canvas_clear(), tvg_canvas_destroy()"]
    pub fn tvg_paint_del(paint: *mut Tvg_Paint) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Scales the given Tvg_Paint object by the given factor.\n\n \\param[in] paint The Tvg_Paint object to be scaled.\n \\param[in] factor The value of the scaling factor. The default value is 1.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with memory allocation."]
    pub fn tvg_paint_scale(paint: *mut Tvg_Paint, factor: f32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Rotates the given Tvg_Paint by the given angle.\n\n The angle in measured clockwise from the horizontal axis.\n The rotational axis passes through the point on the object with zero coordinates.\n\n \\param[in] paint The Tvg_Paint object to be rotated.\n \\param[in] degree The value of the rotation angle in degrees.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with memory allocation."]
    pub fn tvg_paint_rotate(paint: *mut Tvg_Paint, degree: f32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Moves the given Tvg_Paint in a two-dimensional space.\n\n The origin of the coordinate system is in the upper left corner of the canvas.\n The horizontal and vertical axes point to the right and down, respectively.\n\n \\param[in] paint The Tvg_Paint object to be shifted.\n \\param[in] x The value of the horizontal shift.\n \\param[in] y The value of the vertical shift.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with memory allocation."]
    pub fn tvg_paint_translate(paint: *mut Tvg_Paint, x: f32, y: f32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Transforms the given Tvg_Paint using the augmented transformation matrix.\n\n The augmented matrix of the transformation is expected to be given.\n\n \\param[in] paint The Tvg_Paint object to be transformed.\n \\param[in] m The 3x3 augmented matrix.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr is passed as the argument.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with memory allocation."]
    pub fn tvg_paint_set_transform(paint: *mut Tvg_Paint, m: *const Tvg_Matrix) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the matrix of the affine transformation of the given Tvg_Paint object.\n\n In case no transformation was applied, the identity matrix is returned.\n\n \\param[in] paint The Tvg_Paint object of which to get the transformation matrix.\n \\param[out] m The 3x3 augmented matrix.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr is passed as the argument."]
    pub fn tvg_paint_get_transform(paint: *mut Tvg_Paint, m: *mut Tvg_Matrix) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the opacity of the given Tvg_Paint.\n\n \\param[in] paint The Tvg_Paint object of which the opacity value is to be set.\n \\param[in] opacity The opacity value in the range [0 ~ 255], where 0 is completely transparent and 255 is opaque.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n\n \\note Setting the opacity with this API may require multiple renderings using a composition. It is recommended to avoid changing the opacity if possible."]
    pub fn tvg_paint_set_opacity(paint: *mut Tvg_Paint, opacity: u8) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the opacity of the given Tvg_Paint.\n\n \\param[in] paint The Tvg_Paint object of which to get the opacity value.\n \\param[out] opacity The opacity value in the range [0 ~ 255], where 0 is completely transparent and 255 is opaque.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT In case a @c nullptr is passed as the argument."]
    pub fn tvg_paint_get_opacity(paint: *const Tvg_Paint, opacity: *mut u8) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Duplicates the given Tvg_Paint object.\n\n Creates a new object and sets its all properties as in the original object.\n\n \\param[in] paint The Tvg_Paint object to be copied.\n\n \\return A copied Tvg_Paint object if succeed, @c nullptr otherwise."]
    pub fn tvg_paint_duplicate(paint: *mut Tvg_Paint) -> *mut Tvg_Paint;
}
extern "C" {
    #[doc = " \\brief Gets the axis-aligned bounding box of the Tvg_Paint object.\n\n \\param[in] paint The Tvg_Paint object of which to get the bounds.\n \\param[out] x The x coordinate of the upper left corner of the object.\n \\param[out] y The y coordinate of the upper left corner of the object.\n \\param[out] w The width of the object.\n \\param[out] h The height of the object.\n \\param[in] transformed If @c true, the transformation of the paint is taken into account, otherwise it isn't.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION Other errors.\n\n \\note The bounding box doesn't indicate the actual drawing region. It's the smallest rectangle that encloses the object."]
    pub fn tvg_paint_get_bounds(
        paint: *const Tvg_Paint,
        x: *mut f32,
        y: *mut f32,
        w: *mut f32,
        h: *mut f32,
        transformed: bool,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the composition target object and the composition method.\n\n \\param[in] paint The source object of the composition.\n \\param[in] target The target object of the composition.\n \\param[in] method The method used to composite the source object with the target.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid @p paint or @p target object or the @p method equal to TVG_COMPOSITE_METHOD_NONE."]
    pub fn tvg_paint_set_composite_method(
        paint: *mut Tvg_Paint,
        target: *mut Tvg_Paint,
        method: Tvg_Composite_Method,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the composition target object and the composition method.\n\n \\param[in] paint The source object of the composition.\n \\param[out] target The target object of the composition.\n \\param[out] method The method used to composite the source object with the target.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr is passed as the argument."]
    pub fn tvg_paint_get_composite_method(
        paint: *const Tvg_Paint,
        target: *mut *const Tvg_Paint,
        method: *mut Tvg_Composite_Method,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the unique id value of the paint instance indicating the instance type.\n\n \\param[in] paint The Tvg_Paint object of which to get the identifier value.\n \\param[out] identifier The unique identifier of the paint instance type.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT In case a @c nullptr is passed as the argument.\n\n \\since 0.9"]
    pub fn tvg_paint_get_identifier(
        paint: *const Tvg_Paint,
        identifier: *mut Tvg_Identifier,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = "/\n/*!\n \\brief Creates a new shape object.\n\n \\return A new shape object."]
    pub fn tvg_shape_new() -> *mut Tvg_Paint;
}
extern "C" {
    #[doc = " \\brief Resets the shape path properties.\n\n The color, the fill and the stroke properties are retained.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n\n \\note The memory, where the path data is stored, is not deallocated at this stage for caching effect."]
    pub fn tvg_shape_reset(paint: *mut Tvg_Paint) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the initial point of the sub-path.\n\n The value of the current point is set to the given point.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] x The horizontal coordinate of the initial point of the sub-path.\n \\param[in] y The vertical coordinate of the initial point of the sub-path.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer."]
    pub fn tvg_shape_move_to(paint: *mut Tvg_Paint, x: f32, y: f32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Adds a new point to the sub-path, which results in drawing a line from the current point to the given end-point.\n\n The value of the current point is set to the given end-point.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] x The horizontal coordinate of the end-point of the line.\n \\param[in] y The vertical coordinate of the end-point of the line.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n\n \\note In case this is the first command in the path, it corresponds to the tvg_shape_move_to() call."]
    pub fn tvg_shape_line_to(paint: *mut Tvg_Paint, x: f32, y: f32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Adds new points to the sub-path, which results in drawing a cubic Bezier curve.\n\n The Bezier curve starts at the current point and ends at the given end-point (@p x, @p y). Two control points (@p cx1, @p cy1) and (@p cx2, @p cy2) are used to determine the shape of the curve.\n The value of the current point is set to the given end-point.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] cx1 The horizontal coordinate of the 1st control point.\n \\param[in] cy1 The vertical coordinate of the 1st control point.\n \\param[in] cx2 The horizontal coordinate of the 2nd control point.\n \\param[in] cy2 The vertical coordinate of the 2nd control point.\n \\param[in] x The horizontal coordinate of the endpoint of the curve.\n \\param[in] y The vertical coordinate of the endpoint of the curve.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n\n \\note In case this is the first command in the path, no data from the path are rendered."]
    pub fn tvg_shape_cubic_to(
        paint: *mut Tvg_Paint,
        cx1: f32,
        cy1: f32,
        cx2: f32,
        cy2: f32,
        x: f32,
        y: f32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Closes the current sub-path by drawing a line from the current point to the initial point of the sub-path.\n\n The value of the current point is set to the initial point of the closed sub-path.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n\n \\note In case the sub-path does not contain any points, this function has no effect."]
    pub fn tvg_shape_close(paint: *mut Tvg_Paint) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Appends a rectangle to the path.\n\n The rectangle with rounded corners can be achieved by setting non-zero values to @p rx and @p ry arguments.\n The @p rx and @p ry values specify the radii of the ellipse defining the rounding of the corners.\n\n The position of the rectangle is specified by the coordinates of its upper left corner -  @p x and @p y arguments.\n\n The rectangle is treated as a new sub-path - it is not connected with the previous sub-path.\n\n The value of the current point is set to (@p x + @p rx, @p y) - in case @p rx is greater\n than @p w/2 the current point is set to (@p x + @p w/2, @p y)\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] x The horizontal coordinate of the upper left corner of the rectangle.\n \\param[in] y The vertical coordinate of the upper left corner of the rectangle.\n \\param[in] w The width of the rectangle.\n \\param[in] h The height of the rectangle.\n \\param[in] rx The x-axis radius of the ellipse defining the rounded corners of the rectangle.\n \\param[in] ry The y-axis radius of the ellipse defining the rounded corners of the rectangle.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n\n& \\note For @p rx and @p ry greater than or equal to the half of @p w and the half of @p h, respectively, the shape become an ellipse."]
    pub fn tvg_shape_append_rect(
        paint: *mut Tvg_Paint,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
        rx: f32,
        ry: f32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Appends an ellipse to the path.\n\n The position of the ellipse is specified by the coordinates of its center - @p cx and @p cy arguments.\n\n The ellipse is treated as a new sub-path - it is not connected with the previous sub-path.\n\n The value of the current point is set to (@p cx, @p cy - @p ry).\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] cx The horizontal coordinate of the center of the ellipse.\n \\param[in] cy The vertical coordinate of the center of the ellipse.\n \\param[in] rx The x-axis radius of the ellipse.\n \\param[in] ry The y-axis radius of the ellipse.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer."]
    pub fn tvg_shape_append_circle(
        paint: *mut Tvg_Paint,
        cx: f32,
        cy: f32,
        rx: f32,
        ry: f32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Appends a circular arc to the path.\n\n The arc is treated as a new sub-path - it is not connected with the previous sub-path.\n The current point value is set to the end-point of the arc in case @p pie is @c false, and to the center of the arc otherwise.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] cx The horizontal coordinate of the center of the arc.\n \\param[in] cy The vertical coordinate of the center of the arc.\n \\param[in] radius The radius of the arc.\n \\param[in] startAngle The start angle of the arc given in degrees, measured counter-clockwise from the horizontal line.\n \\param[in] sweep The central angle of the arc given in degrees, measured counter-clockwise from @p startAngle.\n \\param[in] pie Specifies whether to draw radii from the arc's center to both of its end-point - drawn if @c true.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n\n \\note Setting @p sweep value greater than 360 degrees, is equivalent to calling tvg_shape_append_circle(paint, cx, cy, radius, radius)."]
    pub fn tvg_shape_append_arc(
        paint: *mut Tvg_Paint,
        cx: f32,
        cy: f32,
        radius: f32,
        startAngle: f32,
        sweep: f32,
        pie: u8,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Appends a given sub-path to the path.\n\n The current point value is set to the last point from the sub-path.\n For each command from the @p cmds array, an appropriate number of points in @p pts array should be specified.\n If the number of points in the @p pts array is different than the number required by the @p cmds array, the shape with this sub-path will not be displayed on the screen.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] cmds The array of the commands in the sub-path.\n \\param[in] cmdCnt The length of the @p cmds array.\n \\param[in] pts The array of the two-dimensional points.\n \\param[in] ptsCnt The length of the @p pts array.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr passed as the argument or @p cmdCnt or @p ptsCnt equal to zero."]
    pub fn tvg_shape_append_path(
        paint: *mut Tvg_Paint,
        cmds: *const Tvg_Path_Command,
        cmdCnt: u32,
        pts: *const Tvg_Point,
        ptsCnt: u32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the points values of the path.\n\n The function does not allocate any data, it operates on internal memory. There is no need to free the @p pts array.\n\n \\code\n Tvg_Shape *shape = tvg_shape_new();\n Tvg_Point *coords = NULL;\n uint32_t len = 0;\n\n tvg_shape_append_circle(shape, 10, 10, 50, 50);\n tvg_shape_get_path_coords(shape, (const Tvg_Point**)&coords, &len);\n //TVG approximates a circle by four Bezier curves. In the example above the coords array stores their coordinates.\n \\endcode\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] pts The pointer to the array of the two-dimensional points from the path.\n \\param[out] cnt The length of the @p pts array.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr passed as the argument."]
    pub fn tvg_shape_get_path_coords(
        paint: *const Tvg_Paint,
        pts: *mut *const Tvg_Point,
        cnt: *mut u32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the commands data of the path.\n\n The function does not allocate any data. There is no need to free the @p cmds array.\n\n \\code\n Tvg_Shape *shape = tvg_shape_new();\n Tvg_Path_Command *cmds = NULL;\n uint32_t len = 0;\n\n tvg_shape_append_circle(shape, 10, 10, 50, 50);\n tvg_shape_get_path_commands(shape, (const Tvg_Path_Command**)&cmds, &len);\n //TVG approximates a circle by four Bezier curves. In the example above the cmds array stores the commands of the path data.\n \\endcode\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] cmds The pointer to the array of the commands from the path.\n \\param[out] cnt The length of the @p cmds array.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr passed as the argument."]
    pub fn tvg_shape_get_path_commands(
        paint: *const Tvg_Paint,
        cmds: *mut *const Tvg_Path_Command,
        cnt: *mut u32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the stroke width for all of the figures from the @p paint.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] width The width of the stroke. The default value is 0.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation."]
    pub fn tvg_shape_set_stroke_width(paint: *mut Tvg_Paint, width: f32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the shape's stroke width.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] width The stroke width.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer passed as an argument."]
    pub fn tvg_shape_get_stroke_width(paint: *const Tvg_Paint, width: *mut f32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the shape's stroke color.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] r The red color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[in] g The green color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[in] b The blue color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[in] a The alpha channel value in the range [0 ~ 255], where 0 is completely transparent and 255 is opaque.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation.\n\n \\note Either a solid color or a gradient fill is applied, depending on what was set as last."]
    pub fn tvg_shape_set_stroke_color(
        paint: *mut Tvg_Paint,
        r: u8,
        g: u8,
        b: u8,
        a: u8,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the shape's stroke color.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] r The red color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[out] g The green color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[out] b The blue color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[out] a The alpha channel value in the range [0 ~ 255], where 0 is completely transparent and 255 is opaque.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION No stroke was set."]
    pub fn tvg_shape_get_stroke_color(
        paint: *const Tvg_Paint,
        r: *mut u8,
        g: *mut u8,
        b: *mut u8,
        a: *mut u8,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the linear gradient fill of the stroke for all of the figures from the path.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] grad The linear gradient fill.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation.\n \\retval TVG_RESULT_MEMORY_CORRUPTION An invalid Tvg_Gradient pointer.\n\n \\note Either a solid color or a gradient fill is applied, depending on what was set as last."]
    pub fn tvg_shape_set_stroke_linear_gradient(
        paint: *mut Tvg_Paint,
        grad: *mut Tvg_Gradient,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the radial gradient fill of the stroke for all of the figures from the path.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] grad The radial gradient fill.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation.\n \\retval TVG_RESULT_MEMORY_CORRUPTION An invalid Tvg_Gradient pointer.\n\n \\note Either a solid color or a gradient fill is applied, depending on what was set as last."]
    pub fn tvg_shape_set_stroke_radial_gradient(
        paint: *mut Tvg_Paint,
        grad: *mut Tvg_Gradient,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the gradient fill of the shape's stroke.\n\n The function does not allocate any memory.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] grad The gradient fill.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer passed as an argument."]
    pub fn tvg_shape_get_stroke_gradient(
        paint: *const Tvg_Paint,
        grad: *mut *mut Tvg_Gradient,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the shape's stroke dash pattern.\n\n \\code\n //dash pattern examples\n float dashPattern[2] = {20, 10};  // -- -- --\n float dashPattern[2] = {40, 20};  // ----  ----  ----\n float dashPattern[4] = {10, 20, 30, 40} // -  ---    -  ---\n \\endcode\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] dashPattern The array of consecutive pair values of the dash length and the gap length.\n \\param[in] cnt The size of the @p dashPattern array.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer passed as an argument and @p cnt > 0, the given length of the array is less than two or any of the @p dashPattern values is zero or less.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation.\n\n \\note To reset the stroke dash pattern, pass @c nullptr to @p dashPattern and zero to @p cnt."]
    pub fn tvg_shape_set_stroke_dash(
        paint: *mut Tvg_Paint,
        dashPattern: *const f32,
        cnt: u32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the dash pattern of the stroke.\n\n The function does not allocate any memory.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] dashPattern The array of consecutive pair values of the dash length and the gap length.\n \\param[out] cnt The size of the @p dashPattern array.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer passed as an argument."]
    pub fn tvg_shape_get_stroke_dash(
        paint: *const Tvg_Paint,
        dashPattern: *mut *const f32,
        cnt: *mut u32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the cap style used for stroking the path.\n\n The cap style specifies the shape to be used at the end of the open stroked sub-paths.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] cap The cap style value. The default value is @c TVG_STROKE_CAP_SQUARE.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation."]
    pub fn tvg_shape_set_stroke_cap(paint: *mut Tvg_Paint, cap: Tvg_Stroke_Cap) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the stroke cap style used for stroking the path.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] cap The cap style value.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer passed as an argument."]
    pub fn tvg_shape_get_stroke_cap(
        paint: *const Tvg_Paint,
        cap: *mut Tvg_Stroke_Cap,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the join style for stroked path segments.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] join The join style value. The default value is @c TVG_STROKE_JOIN_BEVEL.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation."]
    pub fn tvg_shape_set_stroke_join(paint: *mut Tvg_Paint, join: Tvg_Stroke_Join) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief The function gets the stroke join method\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] join The join style value.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer passed as an argument."]
    pub fn tvg_shape_get_stroke_join(
        paint: *const Tvg_Paint,
        join: *mut Tvg_Stroke_Join,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the stroke miterlimit.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] miterlimit The miterlimit imposes a limit on the extent of the stroke join when the @c TVG_STROKE_JOIN_MITER join style is set. The default value is 4.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_NOT_SUPPORTED Unsupported value.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation.\n\n \\since 0.11"]
    pub fn tvg_shape_set_stroke_miterlimit(paint: *mut Tvg_Paint, miterlimit: f32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief The function gets the stroke miterlimit.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] miterlimit The stroke miterlimit.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer passed as an argument.\n\n \\since 0.11"]
    pub fn tvg_shape_get_stroke_miterlimit(
        paint: *const Tvg_Paint,
        miterlimit: *mut f32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the shape's solid color.\n\n The parts of the shape defined as inner are colored.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] r The red color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[in] g The green color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[in] b The blue color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[in] a The alpha channel value in the range [0 ~ 255], where 0 is completely transparent and 255 is opaque. The default value is 0.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n\n \\note Either a solid color or a gradient fill is applied, depending on what was set as last.\n \\see tvg_shape_set_fill_rule()"]
    pub fn tvg_shape_set_fill_color(
        paint: *mut Tvg_Paint,
        r: u8,
        g: u8,
        b: u8,
        a: u8,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the shape's solid color.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] r The red color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[out] g The green color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[out] b The blue color channel value in the range [0 ~ 255]. The default value is 0.\n \\param[out] a The alpha channel value in the range [0 ~ 255], where 0 is completely transparent and 255 is opaque. The default value is 0.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer."]
    pub fn tvg_shape_get_fill_color(
        paint: *const Tvg_Paint,
        r: *mut u8,
        g: *mut u8,
        b: *mut u8,
        a: *mut u8,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the shape's fill rule.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] rule The fill rule value. The default value is @c TVG_FILL_RULE_WINDING.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer."]
    pub fn tvg_shape_set_fill_rule(paint: *mut Tvg_Paint, rule: Tvg_Fill_Rule) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the shape's fill rule.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] rule shape's fill rule\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer passed as an argument."]
    pub fn tvg_shape_get_fill_rule(paint: *const Tvg_Paint, rule: *mut Tvg_Fill_Rule)
        -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the rendering order of the stroke and the fill.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] strokeFirst If @c true the stroke is rendered before the fill, otherwise the stroke is rendered as the second one (the default option).\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation.\n\n \\since 0.10"]
    pub fn tvg_shape_set_paint_order(paint: *mut Tvg_Paint, strokeFirst: bool) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the linear gradient fill for all of the figures from the path.\n\n The parts of the shape defined as inner are filled.\n\n \\code\n Tvg_Gradient* grad = tvg_linear_gradient_new();\n tvg_linear_gradient_set(grad, 700, 700, 800, 800);\n Tvg_Color_Stop color_stops[4] =\n {\n   {0.0 , 0,   0,   0,   255},\n   {0.25, 255, 0,   0,   255},\n   {0.5 , 0,   255, 0,   255},\n   {1.0 , 0,   0,   255, 255}\n };\n tvg_gradient_set_color_stops(grad, color_stops, 4);\n tvg_shape_set_linear_gradient(shape, grad);\n \\endcode\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] grad The linear gradient fill.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_MEMORY_CORRUPTION An invalid Tvg_Gradient pointer.\n\n \\note Either a solid color or a gradient fill is applied, depending on what was set as last.\n \\see tvg_shape_set_fill_rule()"]
    pub fn tvg_shape_set_linear_gradient(
        paint: *mut Tvg_Paint,
        grad: *mut Tvg_Gradient,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the radial gradient fill for all of the figures from the path.\n\n The parts of the shape defined as inner are filled.\n\n \\code\n Tvg_Gradient* grad = tvg_radial_gradient_new();\n tvg_radial_gradient_set(grad, 550, 550, 50);\n Tvg_Color_Stop color_stops[4] =\n {\n   {0.0 , 0,   0,   0,   255},\n   {0.25, 255, 0,   0,   255},\n   {0.5 , 0,   255, 0,   255},\n   {1.0 , 0,   0,   255, 255}\n };\n tvg_gradient_set_color_stops(grad, color_stops, 4);\n tvg_shape_set_radial_gradient(shape, grad);\n \\endcode\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[in] grad The radial gradient fill.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_MEMORY_CORRUPTION An invalid Tvg_Gradient pointer.\n\n \\note Either a solid color or a gradient fill is applied, depending on what was set as last.\n \\see tvg_shape_set_fill_rule()"]
    pub fn tvg_shape_set_radial_gradient(
        paint: *mut Tvg_Paint,
        grad: *mut Tvg_Gradient,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the gradient fill of the shape.\n\n The function does not allocate any data.\n\n \\param[in] paint A Tvg_Paint pointer to the shape object.\n \\param[out] grad The gradient fill.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid pointer passed as an argument."]
    pub fn tvg_shape_get_gradient(
        paint: *const Tvg_Paint,
        grad: *mut *mut Tvg_Gradient,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = "/\n/*!\n \\brief Creates a new linear gradient object.\n\n \\code\n Tvg_Paint* shape = tvg_shape_new();\n tvg_shape_append_rect(shape, 700, 700, 100, 100, 20, 20);\n Tvg_Gradient* grad = tvg_linear_gradient_new();\n tvg_linear_gradient_set(grad, 700, 700, 800, 800);\n Tvg_Color_Stop color_stops[2] =\n {\n   {0.0, 0, 0,   0, 255},\n   {1.0, 0, 255, 0, 255},\n };\n tvg_gradient_set_color_stops(grad, color_stops, 2);\n tvg_shape_set_linear_gradient(shape, grad);\n \\endcode\n\n \\return A new linear gradient object."]
    pub fn tvg_linear_gradient_new() -> *mut Tvg_Gradient;
}
extern "C" {
    #[doc = " \\brief Creates a new radial gradient object.\n\n \\code\n Tvg_Paint* shape = tvg_shape_new();\n tvg_shape_append_rect(shape, 700, 700, 100, 100, 20, 20);\n Tvg_Gradient* grad = tvg_radial_gradient_new();\n tvg_radial_gradient_set(grad, 550, 550, 50);\n Tvg_Color_Stop color_stops[2] =\n {\n   {0.0, 0, 0,   0, 255},\n   {1.0, 0, 255, 0, 255},\n };\n tvg_gradient_set_color_stops(grad, color_stops, 2);\n tvg_shape_set_radial_gradient(shape, grad);\n \\endcode\n\n \\return A new radial gradient object."]
    pub fn tvg_radial_gradient_new() -> *mut Tvg_Gradient;
}
extern "C" {
    #[doc = " \\brief Sets the linear gradient bounds.\n\n The bounds of the linear gradient are defined as a surface constrained by two parallel lines crossing\n the given points (@p x1, @p y1) and (@p x2, @p y2), respectively. Both lines are perpendicular to the line linking\n (@p x1, @p y1) and (@p x2, @p y2).\n\n \\param[in] grad The Tvg_Gradient object of which bounds are to be set.\n @param[in] x1 The horizontal coordinate of the first point used to determine the gradient bounds.\n @param[in] y1 The vertical coordinate of the first point used to determine the gradient bounds.\n @param[in] x2 The horizontal coordinate of the second point used to determine the gradient bounds.\n @param[in] y2 The vertical coordinate of the second point used to determine the gradient bounds.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Gradient pointer.\n\n \\note In case the first and the second points are equal, an object filled with such a gradient fill is not rendered."]
    pub fn tvg_linear_gradient_set(
        grad: *mut Tvg_Gradient,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the linear gradient bounds.\n\n The bounds of the linear gradient are defined as a surface constrained by two parallel lines crossing\n the given points (@p x1, @p y1) and (@p x2, @p y2), respectively. Both lines are perpendicular to the line linking\n (@p x1, @p y1) and (@p x2, @p y2).\n\n \\param[in] grad The Tvg_Gradient object of which to get the bounds.\n \\param[out] x1 The horizontal coordinate of the first point used to determine the gradient bounds.\n \\param[out] y1 The vertical coordinate of the first point used to determine the gradient bounds.\n \\param[out] x2 The horizontal coordinate of the second point used to determine the gradient bounds.\n \\param[out] y2 The vertical coordinate of the second point used to determine the gradient bounds.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Gradient pointer."]
    pub fn tvg_linear_gradient_get(
        grad: *mut Tvg_Gradient,
        x1: *mut f32,
        y1: *mut f32,
        x2: *mut f32,
        y2: *mut f32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the radial gradient bounds.\n\n The radial gradient bounds are defined as a circle centered in a given point (@p cx, @p cy) of a given radius.\n\n \\param[in] grad The Tvg_Gradient object of which bounds are to be set.\n \\param[in] cx The horizontal coordinate of the center of the bounding circle.\n \\param[in] cy The vertical coordinate of the center of the bounding circle.\n \\param[in] radius The radius of the bounding circle.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Gradient pointer or the @p radius value less than zero."]
    pub fn tvg_radial_gradient_set(
        grad: *mut Tvg_Gradient,
        cx: f32,
        cy: f32,
        radius: f32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief The function gets radial gradient center point ant radius\n\n \\param[in] grad The Tvg_Gradient object of which bounds are to be set.\n \\param[out] cx The horizontal coordinate of the center of the bounding circle.\n \\param[out] cy The vertical coordinate of the center of the bounding circle.\n \\param[out] radius The radius of the bounding circle.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Gradient pointer."]
    pub fn tvg_radial_gradient_get(
        grad: *mut Tvg_Gradient,
        cx: *mut f32,
        cy: *mut f32,
        radius: *mut f32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the parameters of the colors of the gradient and their position.\n\n \\param[in] grad The Tvg_Gradient object of which the color information is to be set.\n \\param[in] color_stop An array of Tvg_Color_Stop data structure.\n \\param[in] cnt The size of the @p color_stop array equal to the colors number used in the gradient.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Gradient pointer."]
    pub fn tvg_gradient_set_color_stops(
        grad: *mut Tvg_Gradient,
        color_stop: *const Tvg_Color_Stop,
        cnt: u32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the parameters of the colors of the gradient, their position and number\n\n The function does not allocate any memory.\n\n \\param[in] grad The Tvg_Gradient object of which to get the color information.\n \\param[out] color_stop An array of Tvg_Color_Stop data structure.\n \\param[out] cnt The size of the @p color_stop array equal to the colors number used in the gradient.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr passed as the argument."]
    pub fn tvg_gradient_get_color_stops(
        grad: *const Tvg_Gradient,
        color_stop: *mut *const Tvg_Color_Stop,
        cnt: *mut u32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the Tvg_Stroke_Fill value, which specifies how to fill the area outside the gradient bounds.\n\n \\param[in] grad The Tvg_Gradient object.\n \\param[in] spread The FillSpread value.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Gradient pointer."]
    pub fn tvg_gradient_set_spread(grad: *mut Tvg_Gradient, spread: Tvg_Stroke_Fill) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the FillSpread value of the gradient object.\n\n \\param[in] grad The Tvg_Gradient object.\n \\param[out] spread The FillSpread value.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr passed as the argument."]
    pub fn tvg_gradient_get_spread(
        grad: *const Tvg_Gradient,
        spread: *mut Tvg_Stroke_Fill,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Sets the matrix of the affine transformation for the gradient object.\n\n The augmented matrix of the transformation is expected to be given.\n\n \\param[in] grad The Tvg_Gradient object to be transformed.\n \\param[in] m The 3x3 augmented matrix.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr is passed as the argument.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation."]
    pub fn tvg_gradient_set_transform(grad: *mut Tvg_Gradient, m: *const Tvg_Matrix) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the matrix of the affine transformation of the gradient object.\n\n In case no transformation was applied, the identity matrix is set.\n\n \\param[in] grad The Tvg_Gradient object of which to get the transformation matrix.\n \\param[out] m The 3x3 augmented matrix.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr is passed as the argument."]
    pub fn tvg_gradient_get_transform(grad: *const Tvg_Gradient, m: *mut Tvg_Matrix) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the unique id value of the gradient instance indicating the instance type.\n\n \\param[in] grad The Tvg_Gradient object of which to get the identifier value.\n \\param[out] identifier The unique identifier of the gradient instance type.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT In case a @c nullptr is passed as the argument.\n\n \\since 0.9"]
    pub fn tvg_gradient_get_identifier(
        grad: *const Tvg_Gradient,
        identifier: *mut Tvg_Identifier,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Duplicates the given Tvg_Gradient object.\n\n Creates a new object and sets its all properties as in the original object.\n\n \\param[in] grad The Tvg_Gradient object to be copied.\n\n \\return A copied Tvg_Gradient object if succeed, @c nullptr otherwise."]
    pub fn tvg_gradient_duplicate(grad: *mut Tvg_Gradient) -> *mut Tvg_Gradient;
}
extern "C" {
    #[doc = " \\brief Deletes the given gradient object.\n\n \\param[in] grad The gradient object to be deleted.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Gradient pointer."]
    pub fn tvg_gradient_del(grad: *mut Tvg_Gradient) -> Tvg_Result;
}
extern "C" {
    #[doc = "/\n/*!\n \\brief Creates a new picture object.\n\n \\return A new picture object."]
    pub fn tvg_picture_new() -> *mut Tvg_Paint;
}
extern "C" {
    #[doc = " \\brief Loads a picture data directly from a file.\n\n \\param[in] paint A Tvg_Paint pointer to the picture object.\n \\param[in] path The absolute path to the image file.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer or an empty @p path.\n \\retval TVG_RESULT_NOT_SUPPORTED A file with an unknown extension.\n \\retval TVG_RESULT_UNKNOWN An error at a later stage."]
    pub fn tvg_picture_load(
        paint: *mut Tvg_Paint,
        path: *const ::std::os::raw::c_char,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Loads a picture data from a memory block of a given size.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer or no data are provided or the @p width or @p height value is zero or less.\n \\retval TVG_RESULT_FAILED_ALLOCATION A problem with memory allocation occurs.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION An error occurs at a later stage.\n\n \\since 0.9"]
    pub fn tvg_picture_load_raw(
        paint: *mut Tvg_Paint,
        data: *mut u32,
        w: u32,
        h: u32,
        copy: bool,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Loads a picture data from a memory block of a given size.\n\n \\param[in] paint A Tvg_Paint pointer to the picture object.\n \\param[in] data A pointer to a memory location where the content of the picture file is stored.\n \\param[in] size The size in bytes of the memory occupied by the @p data.\n \\param[in] mimetype Mimetype or extension of data such as \"jpg\", \"jpeg\", \"svg\", \"svg+xml\", \"png\", etc. In case an empty string or an unknown type is provided, the loaders will be tried one by one.\n \\param[in] copy If @c true the data are copied into the engine local buffer, otherwise they are not.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT In case a @c nullptr is passed as the argument or the @p size is zero or less.\n \\retval TVG_RESULT_NOT_SUPPORTED A file with an unknown extension.\n \\retval TVG_RESULT_UNKNOWN An error at a later stage.\n\n \\warning: It's the user responsibility to release the @p data memory if the @p copy is @c true."]
    pub fn tvg_picture_load_data(
        paint: *mut Tvg_Paint,
        data: *const ::std::os::raw::c_char,
        size: u32,
        mimetype: *const ::std::os::raw::c_char,
        copy: bool,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Resizes the picture content to the given width and height.\n\n The picture content is resized while keeping the default size aspect ratio.\n The scaling factor is established for each of dimensions and the smaller value is applied to both of them.\n\n \\param[in] paint A Tvg_Paint pointer to the picture object.\n \\param[in] w A new width of the image in pixels.\n \\param[in] h A new height of the image in pixels.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION An internal error."]
    pub fn tvg_picture_set_size(paint: *mut Tvg_Paint, w: f32, h: f32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Gets the size of the loaded picture.\n\n \\param[in] paint A Tvg_Paint pointer to the picture object.\n \\param[out] w A width of the image in pixels.\n \\param[out] h A height of the image in pixels.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer."]
    pub fn tvg_picture_get_size(paint: *const Tvg_Paint, w: *mut f32, h: *mut f32) -> Tvg_Result;
}
extern "C" {
    #[doc = "/\n/*!\n \\brief Creates a new scene object.\n\n A scene object is used to group many paints into one object, which can be manipulated using TVG APIs.\n\n \\return A new scene object."]
    pub fn tvg_scene_new() -> *mut Tvg_Paint;
}
extern "C" {
    #[doc = " \\brief Sets the size of the container, where all the paints pushed into the scene are stored.\n\n If the number of objects pushed into the scene is known in advance, calling the function\n prevents multiple memory reallocation, thus improving the performance.\n\n \\param[in] scene A Tvg_Paint pointer to the scene object.\n \\param[in] size The number of objects for which the memory is to be reserved.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_FAILED_ALLOCATION An internal error with a memory allocation.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Paint pointer."]
    pub fn tvg_scene_reserve(scene: *mut Tvg_Paint, size: u32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Passes drawing elements to the scene using Tvg_Paint objects.\n\n Only the paints pushed into the scene will be the drawn targets.\n The paints are retained by the scene until the tvg_scene_clear() is called.\n If you know the number of pushed objects in advance, please call tvg_scene_reserve().\n\n \\param[in] scene A Tvg_Paint pointer to the scene object.\n \\param[in] paint A graphical object to be drawn.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr passed as the argument.\n \\retval TVG_RESULT_MEMORY_CORRUPTION An internal error.\n\n \\note The rendering order of the paints is the same as the order as they were pushed. Consider sorting the paints before pushing them if you intend to use layering."]
    pub fn tvg_scene_push(scene: *mut Tvg_Paint, paint: *mut Tvg_Paint) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Clears a Tvg_Scene objects from pushed paints.\n\n Tvg_Paint objects stored in the scene are released if @p free is set to @c true, otherwise the memory is not deallocated and\n all paints should be released manually in order to avoid memory leaks.\n\n \\param[in] scene The Tvg_Scene object to be cleared.\n \\param[in] free If @c true the memory occupied by paints is deallocated, otherwise it is not.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Canvas pointer.\n\n \\warning Please use the @p free argument only when you know how it works, otherwise it's not recommended."]
    pub fn tvg_scene_clear(scene: *mut Tvg_Paint, free: bool) -> Tvg_Result;
}
extern "C" {
    #[doc = "/\n/*!\n \\brief Creates a new Tvg_Saver object.\n\n \\return A new Tvg_Saver object."]
    pub fn tvg_saver_new() -> *mut Tvg_Saver;
}
extern "C" {
    #[doc = " \\brief Exports the given @p paint data to the given @p path\n\n If the saver module supports any compression mechanism, it will optimize the data size.\n This might affect the encoding/decoding time in some cases. You can turn off the compression\n if you wish to optimize for speed.\n\n \\param[in] saver The Tvg_Saver object connected with the saving task.\n \\param[in] paint The paint to be saved with all its associated properties.\n \\param[in] path A path to the file, in which the paint data is to be saved.\n \\param[in] compress If @c true then compress data if possible.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr passed as the argument.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION Currently saving other resources.\n \\retval TVG_RESULT_NOT_SUPPORTED Trying to save a file with an unknown extension or in an unsupported format.\n \\retval TVG_RESULT_MEMORY_CORRUPTION An internal error.\n \\retval TVG_RESULT_UNKNOWN An empty paint is to be saved.\n\n \\note Saving can be asynchronous if the assigned thread number is greater than zero. To guarantee the saving is done, call tvg_saver_sync() afterwards.\n \\see tvg_saver_sync()"]
    pub fn tvg_saver_save(
        saver: *mut Tvg_Saver,
        paint: *mut Tvg_Paint,
        path: *const ::std::os::raw::c_char,
        compress: bool,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Guarantees that the saving task is finished.\n\n The behavior of the Saver module works on a sync/async basis, depending on the threading setting of the Initializer.\n Thus, if you wish to have a benefit of it, you must call tvg_saver_sync() after the tvg_saver_save() in the proper delayed time.\n Otherwise, you can call tvg_saver_sync() immediately.\n\n \\param[in] saver The Tvg_Saver object connected with the saving task.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT A @c nullptr passed as the argument.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION No saving task is running.\n\n \\note The asynchronous tasking is dependent on the Saver module implementation.\n \\see tvg_saver_save()"]
    pub fn tvg_saver_sync(saver: *mut Tvg_Saver) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Deletes the given Tvg_Saver object.\n\n \\param[in] saver The Tvg_Saver object to be deleted.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Saver pointer."]
    pub fn tvg_saver_del(saver: *mut Tvg_Saver) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Creates a new Animation object. (BETA_API)\n\n \\return Tvg_Animation A new Tvg_Animation object."]
    pub fn tvg_animation_new() -> *mut Tvg_Animation;
}
extern "C" {
    #[doc = " \\brief Specifies the current frame in the animation. (BETA_API)\n\n \\param[in] animation A Tvg_Animation pointer to the animation object.\n \\param[in] no The index of the animation frame to be displayed. The index should be less than the tvg_animatio_total_frame().\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Animation pointer.\n \\retval TVG_RESULT_INSUFFICIENT_CONDITION No animatable data loaded from the Picture.\n \\retval TVG_RESULT_NOT_SUPPORTED The picture data does not support animations.\n\n \\see tvg_animation_get_total_frame()"]
    pub fn tvg_animation_set_frame(animation: *mut Tvg_Animation, no: u32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Retrieves a picture instance associated with this animation instance. (BETA_API)\n\n This function provides access to the picture instance that can be used to load animation formats, such as Lottie(json).\n After setting up the picture, it can be pushed to the designated canvas, enabling control over animation frames\n with this Animation instance.\n\n \\param[in] animation A Tvg_Animation pointer to the animation object.\n\n \\return A picture instance that is tied to this animation.\n\n \\warning The picture instance is owned by Animation. It should not be deleted manually."]
    pub fn tvg_animation_get_picture(animation: *mut Tvg_Animation) -> *mut Tvg_Paint;
}
extern "C" {
    #[doc = " \\brief Retrieves the current frame number of the animation. (BETA_API)\n\n \\param[in] animation A Tvg_Animation pointer to the animation object.\n \\param[in] no The current frame number of the animation, between 0 and totalFrame() - 1.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Animation pointer or @p no\n\n \\see tvg_animation_get_total_frame()\n \\see tvg_animation_set_frame()"]
    pub fn tvg_animation_get_frame(animation: *mut Tvg_Animation, no: *mut u32) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Retrieves the total number of frames in the animation. (BETA_API)\n\n \\param[in] animation A Tvg_Animation pointer to the animation object.\n \\param[in] cnt The total number of frames in the animation.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Animation pointer or @p cnt.\n\n \\note Frame numbering starts from 0.\n \\note If the Picture is not properly configured, this function will return 0."]
    pub fn tvg_animation_get_total_frame(
        animation: *mut Tvg_Animation,
        cnt: *mut u32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Retrieves the duration of the animation in seconds. (BETA_API)\n\n \\param[in] animation A Tvg_Animation pointer to the animation object.\n \\param[in] duration The duration of the animation in seconds.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Animation pointer or @p duration.\n\n \\note If the Picture is not properly configured, this function will return 0."]
    pub fn tvg_animation_get_duration(
        animation: *mut Tvg_Animation,
        duration: *mut f32,
    ) -> Tvg_Result;
}
extern "C" {
    #[doc = " \\brief Deletes the given Tvg_Animation object.\n\n \\param[in] animation The Tvg_Animation object to be deleted.\n\n \\return Tvg_Result enumeration.\n \\retval TVG_RESULT_SUCCESS Succeed.\n \\retval TVG_RESULT_INVALID_ARGUMENT An invalid Tvg_Animation pointer."]
    pub fn tvg_animation_del(animation: *mut Tvg_Animation) -> Tvg_Result;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
